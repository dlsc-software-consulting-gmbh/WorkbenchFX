= Technical Report: WorkbenchFX
François Martin; Marco Sanfratello

Customer: http://www.dlsc.com[Dirk Lemmermann Software & Consulting]

// Check symbol
:y: &#10003;
// Ensures references are displayed in "Figure x" format
:xrefstyle: short

// TODO: differentiate somewhere the terms "implementor", "user" and "API user"
// TODO: explain persona early, so it can be referenced later in the text
== Abstract / Management summary

== Introduction
The paradigm of WorkbenchFX is: "Make everything possible. Expect the least."
This will end with a citation cite:[noauthor_system_nodate].

== The way to WorkbenchFX
=== Briefing

=== Syntax
// TODO: Fluent API or not?

=== First thoughts

=== Why should someone use our Workbench instead of coding on their own?
* Simple Design
* Fast
* Fast learning curve
* Easy to use
* Modular
* Extendable

== Analysis

=== Naming
==== Navigation Drawer
Comes from Material Design: https://material.io/guidelines/patterns/navigation-drawer.html

==== Module Naming
To plug in functionality by the API user, we use modules.
However, the name `Module` is not ideal, since that name already has a lot of associations.
Additionally, when typing `extends Module` in an IDE, it will automatically imports Java's `Module`.
This makes it frustrating, as the implementor has to manually change the import.

To avoid confusion, we want to come up with a name which makes it clearer and less ambiguous.
We did a brainstorming to come up with ideas for possible names for `Module` (<<img-brainstorming-module>>).

.Brainstorming of possible names for `Module`.
[#img-brainstorming-module]
image::include/brainstorming_module.jpg[Module Brainstorming]

We discussed this with our customer and even though we did the brainstorming and came up with a lot of names, none of them seemed to feel "right".
Even though the name `Module` has a lot of associations, it's the only name that makes sense for what it stands for.
In the end, we decided to rename `Module` to `WorkbenchModule`.
We thought it would be easier to understand for our API users and that was the most important factor for us in this decision.
This is why we decided to stick with the word `Module`.
However, we decided to add the `Workbench` prefix, to remedy the importing issue mentioned above and to clearly separate it from the other `Module` classes in the JDK.

== Architecture
// TODO: rework entirely, separate docking etc. from "simple approach" text, and merge it with the evaluation of tools etc.

API Users of WorkbenchFX don't only care about the API design, but also about the customizibility.
//They want to be able to define their own design to ensure it blends in with the design of their components.
//The standard for custom controls in JavaFX is to use an implementation based on a control, separated from the skin. TODO: source?
//TODO: maybe explain a little with graphics how this structure works?


=== Modular Approach
Power users need the utmost of customizability, to ensure they can adapt the workspace to be the most ergonomic to fit their workflow.
In terms of the architecture, it could mean that it would need to allow the following:

* Separation between `Control` and `Skin`
** Skin can be replaced by API users, if they want to use a custom style
* Flexible panes
** can be rearranged across the whole window
** different modes for fixation
*** Pinned mode
*** Docked mode
*** Floating mode
*** Window mode
*** Split mode

=== Simple Approach
Our customer states that the intended API user would not have the need to entirely replace the `Skin`, as it is rarely done.
At first we didn't separate between `Control` and `Skin` for this reason.
Later on, our customer told us he would still consider the `Workbench` to be a `Control`, and that it would make more sense if used with https://gluonhq.com/products/scene-builder/[Scene Builder].
This is why we decided to have the `Workbench` extend `Control` and split it up into `Workbench` and `WorkbenchSkin`.
However, since we decided the API user would not want to replace the `WorkbenchSkin`, we decided to make `Workbench` and `WorkbenchSkin` final.
With this, we make it clear that `Workbench` and `WorkbenchSkin` are not designed to be subclassed.

This also means that we don't need to design the panes we use internally to be replaceable by the API user.
It is more important that the user experience is straightforward.
Still, the possibility of extending the workbench using modules is important to our customer.

=== WorkbenchModule Lifecycle
The following UML diagrams explain how the lifecycle of a `WorkbenchModule` works.
The diagrams are simplified to a degree that is relevant for the implementor of a `WorkbenchModule` and are *not* complete and *not* exhaustive by design.
The goal is to explain the principle of interactions on modules when using `Workbench#openModule(WorkbenchModule)` and `Workbench#closeModule(WorkbenchModule)` with a minimal amount of examples.

*Generally*, when clicking on a tile in the `AddModuleView`, `Workbench#openModule(WorkbenchModule)` gets called. +
When clicking on the `x` icon of a tab, `Workbench#closeModule(WorkbenchModule)` gets called.

Overview of the lifecycle in a state diagram, showing all state changes that can occur (<<img-module-lifecycle>>).

.Module Lifecycle.
[#img-module-lifecycle]
image::include/UML/svg/Module Lifecycle.svg[Module Lifecycle]

Process of opening two modules in sequence, followed by opening the first module again (<<img-open-module>>).

.Opening of modules.
[#img-open-module]
image::include/UML/svg/Opening of Modules.svg[Opening of Modules]

Two open modules, closing of the active module (<<img-close-module-active>>).

.Closing of modules, active module.
[#img-close-module-active]
image::include/UML/svg/Close Module Active.svg[Close Module Active]

Two open modules, closing of the inactive module (<<img-close-module-inactive>>).

.Closing of modules, inactive module.
[#img-close-module-inactive]
image::include/UML/svg/Close Module Inactive.svg[Close Module Inactive]

Two open modules, closing of the active module, where the call to `WorkbenchModule#destroy()` returns false (<<img-close-module-interrupt-active>>).
This leads to the closing process getting interrupted.
The implementor of `WorkbenchModule` can then choose to do cleanup actions or open a confirmation dialog, following a call to `WorkbenchModule#close()`, when the module should definitely be closed.

.Closing of modules interrupted, active module.
[#img-close-module-interrupt-active]
image::include/UML/svg/Close Module Interrupted Active.svg[Close Module Interrupted Active]

Two open modules, closing of the inactive module, where the call to `WorkbenchModule#destroy()` returns false (<<img-close-module-interrupt-inactive>>).
This leads to the closing process getting interrupted.
The module which interrupted the closing process will be opened, so that the user's attention will be directed towards the interrupting module, so they can take appropriate actions.

.Closing of modules interrupted, inactive module.
[#img-close-module-interrupt-inactive]
image::include/UML/svg/Close Module Interrupted Inactive.svg[Close Module Interrupted Inactive]

To learn more about the interactions in detail, look at the tests below, since the tests verify the exact order of the calls and cover more situations in detail:

* <<test-reference.adoc#_open_modules,Opening of Modules>>
* <<test-reference.adoc#_close_modules,Closing of Modules>>
* <<test-reference.adoc#_close_modules_interrupted,Closing of Modules Interrupted>>

=== API Design of WorkbenchModule
As with the design of the lifecycle, having a simple and easy to understand API overall for `WorkbenchModule` is very important to us.
If there is a lot of code with a lot of methods in the `WorkbenchModule` class, it could make it harder for people to understand how to use the API and how it works.
This is why we very carefully introduced complexity into a `WorkbenchModule`, and only added what really enhanced the user experience to a point that would justify the added code.
We also considered to only add methods which are needed to fulfill a certain use case, which is likely to occur.

==== Added API
One part of a `WorkbenchModule` are its identifying properties.
We decided for a `WorkbenchModule` to have a *name* and an *icon*.
They are necessary, because they are shown in tabs and tiles representing each `WorkbenchModule`.

Every `WorkbenchModule` also has a reference to the `Workbench` object.
This makes it possible to individually adapt the `Workbench` to the needs of a `WorkbenchModule` or to execute tasks like switching to another module.

When we added the module toolbar, we also thought it would make the most sense to include the lists with the `ToolbarItem`s in the `WorkbenchModule` itself, as they are specific for each module.
==== Rejected API
Generally, we decided to not include anything that wasn't strictly specific to a `WorkbenchModule`.

For example, we discussed whether or not to include a list with `WorkbenchModule` specific `MenuItem`s to be shown in the `NavigationDrawer`.
In the end, we decided against it, since the `NavigationDrawer` contains global `MenuItem`s.
If there was one list in `Workbench` and one in each `WorkbenchModule`, API users could get confused.
API users who don't know of the global list in the `Workbench`, could falsely think the `NavigationDrawer` is specific to each module, causing them to add the same `MenuItem`s in each `WorkbenchModule`.
Additionally, some possible open questions it could cause would be:

* Is there a separate module-specific `NavigationDrawer`?
* Does the list of `MenuItem`s in the `WorkbenchModule` override or augment the list in the `Workbench`?
* How are the module-specific and global `MenuItem`s separated?
* Are the module-specific `MenuItem`s inserted on the top or the bottom?

API users are still able to define module-specific `MenuItem`s with the already existing API, by adding them to the global list in `activate()` and removing them in `deactivate()`.
This way, we give the API users the choice of how to include them and they don't miss out on any functionality.
It also eliminates the "guessing" of how it was implemented, as it can be observed above in the possible open questions.

=== Icon: Image vs File vs Node
As for the graphic, there are different ways to implement the inclusion of one in a module.

One possibility is to accept an `Image` object as a parameter of the constructor.
The advantage is, that the API user doesn't need to care about how the image is being displayed
The disadvantage however is, that it is for example not possible to specify a FontAwesome graphic as a `Node`, to use vector objects.

Also, it would be possible to have the API user include an image file in the resources, to use as an graphic.
Using "convention over configuration", the API user would simply choose the same name for the graphic file as for the module, which makes it possible to easily identify the corresponding graphic file of a module.
This brings the advantage of having less code per module, since the graphic doesn't need to be specified in the code.
However, this is also limiting for the same reasons as with the `Image` object above, it is not possible to pass in objects to be displayed.

This is why we decided to have the API user pass in a `Node` object to the constructor of the module.
This allows for a maximum of flexibility and not much overhead in terms of code. // TODO: maybe write more?

// TODO: maybe, decision in AbstractModule between adding "content" as parameter in constructor and overriding init() or not including "content" as parameter and not overriding init(). Chose to do the latter since the node would not be used anywhere else and it would be about the same in terms of code, but is easier to override that way.

=== WorkbenchFxUtils.assertNodeNotSame
// TODO: add comment from AbstractModule, issues with icons as nodes not being possible to display => also to prevent Fabian from making this mistake, throw exception when constructor of AbstractModule is called.

=== MVP
MVP (Model View Presenter) was used as general architecture pattern.
// TODO: why?
At first, we used a separate `WorkbenchModel` object for the model.
Our customer suggests that it would be easier to skip the `WorkbenchModel` class and just put the logic in `Workbench`, since that's the place where he would expect such logic.
We decide to change it in a way that `Workbench` is the model object in the MVP pattern in our case.
This simplifies the architecture and readability is improved, since methods are where they would be expected.

// TODO: used view and presenter class, with view being interface and presenter being abstract.
`View` is an interface, because it's used as a mixin.
We implemented it this way because every view needs to already extend a certain JavaFX class and multiple inheritance is not possible in Java, so using an abstract class here isn't an option.
This makes it possible to initialize all views in the same way while also resulting in less code duplication, since the `init()` method and the JavaDoc doesn't need to be rewritten over and over again.
`Presenter` is abstract, because it acts more like a "super class" of all the presenters.
Since all presenters don't need to extend anything else, using an abstract class here is possible.

=== Builder Pattern
// TODO: explain how builder pattern works in WorkbenchFx.java

=== Overlays
To enable the API user to easily show a custom overlay with the option of having a black transparent `GlassPane` in the background, they can use the respective `WorkbenchFx.showOverlay()` and `WorkbenchFx.hideOverlay()` methods.
// TODO: include code of the above mentioned methods
// TODO: explain glass pane
The GUI of WorkbenchFX is organized in layers.
// TODO: ENTIRELY rework....
At all times, there is a layer of the general WorkbenchFX GUI, which is being represented by the view class `WorkbenchView`.
On top of that is the `GlassPane`, which is generally hidden and is only being displayed if a modal overlay is being shown.
Stacked on top are all of the layers, which are either being added by `Workbench` internally or by the API user.
One example of an internally added layer is the Navigation Drawer, which is being displayed whenever the menu button was pressed.

Overlays must first be loaded by using the `overlays()` method in the builder.
The overlays are initially being loaded hidden and are being displayed on demand by calling `Workbench.showOverlay()`.
This way, initial loading of the application may take longer, since all of the overlays have to be eagerly loaded.
In turn, actions of the user causing an overlay to be displayed are instant and don't require rebuilding of the scene graph.
Users generally prefer to wait a bit longer for an application to startup, rather than waiting for every action to have a longer loading time. // TODO: source?

It is also possible to load an overlay at runtime, using the `Workbench.addOverlay()` method.
However, since this requires a rebuild of the scene graph, it is not recommended. // TODO: source?
This is only recommended when an overlay is so resource intensive, that it can't stay loaded in the background.

// TODO: write more

== Persona
Who are the persona?

[cols="1,1,1"]
.Persona
|===
|link:persona/stefanie_berner.pdf[image:persona/stefanie_berner.png[Stefanie Berner]]
|link:persona/fabian_zimmer.pdf[image:persona/fabian_zimmer.png[Fabian Zimmer]]
|link:persona/anna_leutner.pdf[image:persona/anna_leutner.png[Anna Leutner]]
|===

== Layout
Challenge:
// TODO: ????
* Broad spectrum of usage possibilities (-> reduce to one central use case / user story)
* Unique glossary --> Like in the previous project, we aknowledge, that a shared understanding with the customer is needed.
Thus, we're going to define a unique glossary.
So everyone talks the same language.

To gather information and best practices in order to fulfill the needs of the project, we're going to look at several applications.
This includes features, usability and general appearance of the specific workbench.

== Analysis of existing Applications
// TODO: add text here

=== Blender (Tool for creating 3D models)
* Blender is divided up into five sections.
** Header --> Most important and the common settings
** Left Bar --> Tools
** Right Bar --> Tools
** Footer --> Animation, and view-modes
** Center --> The model, which is created
* All sections are resizable
* If their size becomes 0, they disappear but can be restored using the short code (-)
* Using short codes to show/hide the bars. (+)
Each bar has it's own short code.
There is no animation, when showing or hiding.
No possibility to show/hide the bars manually (-)
* Top right corner --> drag and create so a new window.
Each window shows the same part, but it's view is independent. (+)
To delete the window: Drag the corner back (-)
* Items in a bar can be moved manually, but only in the bar itself.
The bar itself is fixed and can't be moved.
* Items in the bar can be collapsed, in order to save space and make it cleaner.
* The tools in the toolbar are stored in tabs.
* When creating a new project, all settings are restored to default, so nothing can be destroyed. (+ probably give the user opportunity to choose)
// TODO: use table instead of + and -?

=== Photoshop / Illustrator (Design tools)
* Photoshop (Image tool, Pixel based)
**

* Illustrator (Design tool, Vector based)
** Multiple windows possible. Are per default in the background opened. Navigation is done by tabs. (+)
** Tabs can be navigated to other places.
This is done by drag and drop
** Tabs can be placed anywhere in the application (- Needs for sure to be discussed. Has certainly it's advantages)
** Workspace can be restored to default using the equivalent setting. (+)
Custom workspaces can be stored. (+)
Multiple workspaces can be stored and it can be switched to. (+)
** Tabs
*** When double-clicking on the Tabs, they collapse (+)
*** They have 3 states (not likely to understand) and it's collapsing behaviour is not intuitive. (-)
**4
// TODO: use table instead of + and -?

=== IntelliJ
* all possibilities available,
Right click on the tab, then one can decide the behaviour of it.
* "Remove from sidebar" removes the feature from the sidebar and it's not intuitive to restore this. (-)
* "Restore default layout" doesn't restore all layout changes (-)
* Layout changes should be stored at one place.
*
// TODO: use table instead of + and -?

=== MSOffice

=== Sublime Text

== Minimum Viable product (MVP)
As a result of our research we have enough information to create the minimum viable workbench for our use case.
Nonetheless we need to break down the functionality to it's simplest scenario.
// Kunde weiss, dass er ein minimales PRodukt erhält, welches er benutzen kann
// Wir stellen durch MVP sicher, dass ein shared understanding vorhanden ist, und wir vom gleichen reden
This way, we can assure our customer, that the minimal viable product as a result from this project. // TODO: ????
The reason why we do this is, that this way both parties are talking the same language regarding the expectations of the outcome of the project.
Furthermore it's an assurance for both of them.

Characteristic for all programs is: // TODO: move up as conclusion of comparison of programs

* A menu-bar on top of the application.
* Below the menu-bar is often a tool-bar, which contains the current, or most important tools represented through buttons (without collapsing).
* In center is often the window, in which the work is done.
* Usually there are on the left and right of the application bars, which can collapse.
They contain either further tools, buttons or a tree-view for navigation.
* Sometimes another bar which is collapsible is set below the main-window.
* Finally another tool-bar is set below the application.
It contains the least used tools, or tools which are needed at the end of the process.

The outcome of our research results in a minimalistic version of the workbench, our customer developed. // TODO: rewrite
The MVP is designed with the prototyping-tool `Figma`.
It's clickable prototype can be found at:
https://www.figma.com/proto/LY7jPWrDVQ5GG1zmvBdlA2MT/WorkbenchFX?scaling=contain&node-id=47%3A129[figma-prototype]

Below it is shown the final prototype:
[cols="1,1"]
.Minimal Viable Product (MVP)
|===
|link:mvp/home.png[image:mvp/home.png[Home Screen]]
|link:mvp/module.png[image:mvp/module.png[Module Screen]]
|===

== Development Processes

=== SCSS instead of CSS
// TODO: Explain reason why we use SCSS instead of CSS
Less code.
Easier to read.
Plugin for IntelliJ which translates SCSS code into CSS:
https://www.jetbrains.com/help/idea/transpiling-sass-less-and-scss-to-css.html[SCSS to CSS]

There is no margin in JavaFX CSS.
We've made a workaround using a `SCSS Mixin` which looks like this:

Creating the `Mixin`:
[source,sass]
----
@mixin margin-all($margin) {
  -fx-padding: $margin;
  -fx-border-insets: $margin;
  -fx-background-insets: $margin;
}
----

Using the `Mixin` in code:
[source,sass]
----
.my-class {
  @include margin-all(1.5em);
}
----

A `Mixin` includes code, created by the `Mixin` and puts it in the place where it was called.
Link: http://thesassway.com/advanced/pure-sass-functions[SCSS - Mixin]

=== General Conventions
We have decided to define some general conventions:

In CSS it is possible to give multiple classes the same layout.
For example:
[source,sass]
----
.myClass-1, .myClass-2 {
  -fx-padding: 1em;
  -fx-border-insets: 1em;
  -fx-background-insets: 1em;
}
----
this is possible, but it's readability is not that good.
SCSS provides a special tag for such situations, the `@extend`-tag:
[source,sass]
----
.myClass-1 {
  -fx-padding: 1em;
  -fx-border-insets: 1em;
  -fx-background-insets: 1em;
}

.myClass-2 {
  @extend .myClass-1;
}
----
In both cases, both classes have the same attributes.
But the readability is much better in the second example.
Plus, there is the possibility to add another attributes in `.myClass-2`.
[source,sass]
----
.myClass-2 {
  @extend .myClass-1;
  -fx-color: RED;
}
----
`.myClass-2` inherits from `.myClass-1` and can be extended.
https://sass-lang.com/guide[SCSS - @extend]

Another convention we use is the separation of all scss-files.
For readability we have the `main.scss` file separated into multiple scss files.
In the `main.scss` we include all those other files and this "main file" will be compiled as a css file.
Using the `@include` tag looks like this:
[source,sass]
----
@include file1;
@include file2;
@include file3;
----
The files to be included are named with an underscore as prefix: `_file1.scss`.

== Challenges
Setting the node-icon twice:
When creating a new module, one declares a node or an icon for visualizing the module.
After creation, a tab- and a tile-view is created and displayed.
Sadly, the given icon is displayed in only one of the two views.
A short research reveals the problem:
https://stackoverflow.com/questions/27696414/javafx-why-does-adding-a-node-to-a-pane-multiple-times-or-to-different-panes-r[Stack Overflow]

Every `Node` has a `Parent`.
When creating a `TabControl`, the Compiler references the TabControl as the Parent of the icon.
In a next step, we create the `TileControl`.
The Compiler redirects now the Parent-reference of TabControl to the TileControl.
As a result, the icon is only displayed in the TileControl.

=== Module Lifecycle
Designing the module lifecycle was a challenge we didn't expect.
There were a few goals we wanted to achieve:

* Easy to understand
* Self-explanatory sequence and ordering
* Require the least amount of work from Fabian to use it
* Fulfill the needs of Steffi, cover as many use-cases as possible
* Easy to use, even for complex scenarios

If we make it too complex, Fabian could get confused. +
If we require lots of work to use it, Fabian could get frustrated. +
However, if we make it too easy, Steffi can't cover all of her use cases. +
At the same time, making it more complex potentially makes it less self-explanatory, which in turn makes it harder to use.

The challenge was to strike a balance between complex and easy, ensuring both Fabian and Steffi would be happy with the API.

The first design decision we made was to have it as an abstract class.
This way, we can already pre-define as many lifecycle methods as possible, so Fabian has the least amount of work.
Still, we enable Steffi or even Fabian in some more advanced use cases to override the lifecycle methods they need, to augment or replace the implementation with their own.
The compromise here was to have `#activate()` as the only lifecycle method that *must* be implemented, as it returns the view of the module that should be displayed.
But, since the only thing Fabian has to define is `return view;`, which is acceptable.

We realized every module needs a reference to the `Workbench`, but we can't pass it in the constructor, since at the time of the construction of a `WorkbenchModule`, the `Workbench` doesn't exist yet.
This lead to the `#init(Workbench)` lifecycle method, which initially sets the `workbench` reference, but also allows implementors to initialize their module.

Then, we knew we needed lifecycle methods, so the implementor can know whether their module is the currently active module, which lead us to `#activate()` and `#deactivate()`.
This makes it possible for example to have certain module-specific menu-items in the `NavigationDrawer` or `ToolbarItem`s in the Toolbar, by adding them with `#activate()` and removing them with `#deactivate()`.

Finally, we need to allow the implementor to free up resources when a module is closed, which lead us to the `#destroy()` lifecycle method.
This was a bit of a challenge itself though, since initially we thought it would be enough to have `void` as the return type.
Then we realized there could be a use case, in which the implementor may want to open a confirmation dialog before a module is being closed.
Again, we thought about different possible solutions and decided to return a `boolean`, allowing the implementor to specify whether the module can be closed or not.
In case of a confirmation dialog before closing the module, the implementor can simply return `false`, causing the closing of the module to get interrupted.

=== Customizability
Since we want to enable the API user to customize the workbench as much as possible, we need to think about in which way the API user should need to interact with our API to do so.
Of course, the resulting API design from this needs to work with our implementation as well.
When we implemented the pagination in the home screen, we wanted the API user to be able to choose the amount of modules shown per page.
To do so, our initial idea was to design the API for creating a `WorkbenchFx` object like this:
[source,java]
----
WorkbenchFx.of(module1, module2)
           .modulesPerPage(10);
----
This would be very easy to use, but it turned out to be not possible, since the `GridPane` with the module tiles are being initialized in the constructor of `WorkbenchFx`.
Changing the amount of modules per page after the constructor was called, would mean that we would have needed to rebuild all of the pages with the modules again.
This is not only very inefficient, but also a very bad solution for this problem.

Another way of solving this would've been to initialize the `WorkbenchFx` object with a separate method after setting the amount of modules per page, like this:
[source,java]
----
WorkbenchFx.of(module1, module2)
           .modulesPerPage(10)
           .init();
----
This would mean that the `GridPane` with the tiles would only need to be built once.
However, this solution is also very unelegant.
If the API user doesn't want to set the amount of modules per page, they still need to call "init()".
Also, in this case the API user must rememeber to call `init()`, which is easy to forget.

One of the better options would be to solve it like this:
[source,java]
----
WorkbenchFx.of(10, module1, module2);
----
We would simply pass in the amount of modules to the `.of()` method.
This would work, however it has some disadvantages.
For example, the readability suffers: "What does that 10 mean again?".
Also, since we want the API user to be able to define their own controls for the tabs and tiles using factories, we noticed that we also need to pass those factories in the same way.
This would not only make the readability worse, but this also means that if we want to stick to our paradigm, we would need to add multiple overloaded `of()` methods.
With 3 parameters (modules per page, tab and tile factory) this would result in the following combinations:

.Combinations of overloaded WorkbenchFx.of() methods
|===
|No. |Modules per Page |Tab Factory |Tile Factory

|1
|
|
|

|2
|{y}
|
|

|3
|
|{y}
|

|4
|
|
|{y}

|5
|{y}
|{y}
|

|6
|
|{y}
|{y}

|7
|{y}
|{y}
|{y}
|===

Only 3 parameters result in 7 overloaded `of()` methods, which is already quite a lot.
Should we need to add more parameters in the future, it would get even worse.

This is why we decided to go with our final solution, to *use the builder pattern*.
Using it results in the following syntax:
[source,java]
----
WorkbenchFx.builder(module1, module2)
           .modulesPerPage(10)
           .build();
----
This solution solves all of the problems.
It's not possible to forget `build()`, since else it won't return a `WorkbenchFx` object.
It's expandable to a large amount of parameters.
It allows for maximum flexibility, i. e. any combination of the parameters in any order can be specified.
We decided against keeping the original `WorkbenchFx.of(module1, module2)` notation, since using the builder doesn't require a lot more code and doesn't introduce more complexity.



=== Architecture
// if looked at panes during inspiration of architecture => put in
//TODO: describe change from AbstractModule to Module, skip interface in favor of less API pollution, less maintenance, maybe challenge as well?

=== Secret Weapon: Agile
Even though we had to face a lot of challenges, there is one thing we are especially grateful about: working in an agile way. +
Because of the agile approach and having the whole development process transparently on GitHub, we were able to get constant feedback from our customer.
This way, issues or misunderstandings in communication quickly became obvious and we were able to adjust the implementation accordingly right away.
This enabled us to develop a product of very high quality, which meets the demands of our customer and future users alike. +
So in the end, working agile enabled us to quickly identify and resolve challenges.

For example, the separation between `Workbench` and `WorkbenchSkin` only became obvious later in the project (see <<_simple_approach>>).
If we didn't get constant feedback from our customer, we would probably only have recognized this when it was too late - at the end of the project.
Thanks to the agile way, we could resolve this quickly and early on in the project.

== Testing
// TODO: what do we want to cover?
Anzahl Zeilen Code mit Anzahl Zeilen Tests vergleichen

== Build Process
=== GitHub
The programming is being done in a private GitHub repository.
We work by using the GitFlow model // TODO add link.
// TODO explain gitflow
Every change is represented in a pull request to develop from the feature branch(es).
=== Code Review
To improve the quality of the code and also ensure https://www.agilealliance.org/glossary/collective-ownership/[collective code ownership], every pull request gets code reviewed by the other person.
// TODO: maybe add more?
=== Travis CI
To simplify the code review process, we are using Travis CI.
Travis CI is a build server similar to Jenkins.
Compared with Jenkins, it runs in the cloud and is much more straight forward to set up.
The biggest advantage is the tight integration with GitHub, which for example allows automatic builing of pull requests.
GitHub then directly shows the build status in every pull request and we also set up that a pull request can't get merged until the build passes.
With every build, Travis will compile the code, run tests and checkstyle.
We set checkstyle up in a way which makes the build fail, if style violations are found.
This provides us with immediate feedback when we open a new pull request and forget to run checkstyle checks.
Also, it makes it easier for the reviewer, since they don't need to run the tests and checkstyle themselves every time.
// TODO: maybe add more to travis?

In order to not overload the amount of work Travis has to compile we have adjusted the default parapeters for checking each push.
Normally, Travis checks the repo after each push.
To reduce the amount of checks, we have overwritten the settings, so that Travis checks only the last push in case a lot of pushes are made.

Travis makes two checks each time you make a push to the repository.
The first check is the "push-check", which tests the compatibility of the current branch.
The second one is the "pr-check", which emulates a merging with the develop branch in order to check if some errors occur when merging.
This has the huge advantage, that our work is not only easier but also safer to accomplish.
For further information we reference to following link: https://github.com/JuliaGraphs/LightGraphs.jl/issues/475[GitHub issue #475].

== Lessons learned

== Summary

== Bibliography
bibliography::[]

== Honesty Declaration
It is hereby declared that the contents of this report, unless otherwise stated, have been authored by François Martin and Marco Sanfratello. All external sources have been named and quoted material has been attributed appropriately.

The signatures are delivered separately.

// TODO: insert place and date here
